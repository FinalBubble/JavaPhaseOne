# 初识内存

## 1、内存的基本特性

### 现代计算机的基本组成

- 运算器
  - 负责算术运算和逻辑运算，目前已集成到`CPU`中
- 控制器
  - 负责控制系统的各部件，使之协调的工作，目前已集成到`CPU`中
- 存储器
  - 分为主存（内部存储器）和辅存（外部存储器）
- 输入设备
  - 将外部信息/指令传达给系统，例如：鼠标、键盘、麦克风、扫描仪等
- 输出设备
  - 将系统处理后的结果传达给用户，例如：显示器、音响、打印机等

### 关于`CPU`

- `CPU` : ```Central Processing Unit```，中央处理器/中央处理单元
- `CPU`负责进行各种算术运算和逻辑运算
  - 早期显卡还没有`GPU`的年代，计算机的所有运算都是由`CPU`完成的，在显卡有了`GPU`以后，`GPU`也可以分担一部运算，以减轻`CPU`的压力，整体上能提高整机的性能
  - 本次学习以`CPU`负责所有运算为前提来讲解

### 关于存储器

- 存储器用于存储数据，分为主存和辅存
  - 主存（内存）：最主要的存储设备，硬件系统中不可缺少的存储设备，如果硬件系统中没有主存，则无法开机
    - 典型的主存有：主板的`CMOS`，内存条
  - 辅存（外存）：不是必须有的，但可以辅助存储信息，以便于更好的使用计算机的存储设备
    - 典型的辅存有：硬盘，`U`盘，光盘，`SD`卡等
- 在计算机领域，“内存”一般特指“内存条“
  - 在智能手机的相关描述中，”内存“一词极有可能表示的是其”硬盘“，而”运行内存“才是内存条
  - 本次学习中，在没有特别说明的情况下，”内存“均表示“内存条”

### 关于内存

- 内存条是一种`RAM`（```Random Access Memory```），具有以下特点：

  - 可读，可写
    - 另有一种`ROM`（````Read Only Memory````），可读，不可写
  - 一旦断电，数据将全部丢失
  - 正在执行的程序和数据必须加载到内存中
  - `CPU`只会处理内存中的数据
    - 如果需要处理的数据在硬盘上，必须先加载到内存，才可以被`CPU`处理
    - 内存是除了`CPU`内部集成的高速缓存以外，访问效率最高的存储设备

- 内存相当于`CPU`与其他硬件之间的桥梁

- 一些现象：

  - 打开某些软件时，需要等进度条到`100%`才能完全打开
    - 因为软件所需的文件在硬盘上，需先加载到内存，文件载多，加载耗时越久

  - 当你准备玩某个大型游戏时，你可能会事先将已经打开的一些软件关闭
    - 因为正在执行的程序(你准备玩的游戏) 必须在内存中，而你的内存空间是有限的
  - 如果意外关机，你的工作可能没有保存
    - 因为正在处理的数据在内存中，一旦断电，数据将全部失败
  - 当你同时打开很多程序后，计算机会变得很卡
    - 因为很多程序在内存中，就像公路上的汽车太多，堵车后通行效率下降
  - 当你的电脑特别卡，甚至死机，你会通过重启来解决
    - 因为断电后，内存的数据会全部消失，重新开机后，内存中有大量可用空间

- 总的来说，内存的可用空间大小将直接影响当前计算机的流畅程度

  - 就像道路越宽，越不容易堵车

- 内存相对较贵，且受主板限制，所以空间相对较小

  - 以三星为例，``16G``内存与``500G``固态硬盘的售价相差不大
  - 绝大部分千元左右的主板最多支持``128G``内存，而硬盘空间没有限制

- 优质的程序，不会无谓的占用内存空间

  - 需要时占用，用完后释放

## 2、`JVM`垃圾回收机制

- `JVM` :` Java Virtual Machine`，`Java`虚拟机

- 垃圾回收：是`JVM`提供的机制，可以自动化回收垃圾对象占用的内存空间

  - `Java`程序运行时，会产生大量的对象，这些对象会保存在内存中，每个对象都占用一定的存储空间
  - 内存空间是有限的，如果所有对象一直占用内存空间，势必造成内存耗尽
  - 如果某个对象不再被使用，可以将其视为”垃圾“对象
  - `JVM`会自动清理”垃圾“对象的存储空间，使得这部分存储空间可再次被使用
    - 清理过程即是”回收“

- `JVM`垃圾回收机制也称为：`GC`

- `JVM`垃圾回收机制是自动的

  - 这是`Java`的特性之一，在其他编程语言中可能需要你手动处理
  - 当某个对象不再被引用，则会被视为垃圾，后续，垃圾回收机制会清理该对象占用的内存空间（具体细节暂不讨论）
  - 它执行规则人为不可控
    - 定时执行
    - 可用内存不足时执行
    - 接到通知后执行
  - 你可以通过`System.gc()`语句通知`JVM`执行回收
    - 该语句仅通知，`JVM`将知道你希望执行垃圾回收，但何时执行仍由`JVM`决定

- 当你认为某个对象不再需要使用，可以执行以下语句：

  ```java
  object = null; // object是你认为不需要再使用的变量的名称
  ```

- 这条语句可以使得变量不再持有对象的引用，则`JVM`可以将该对象判定为垃圾，在后续的垃圾回收过程中会将其回收

  - 即使你不执行这样的语句，随着变量的作用域消失，也会达到相同效果
    - 一般局部变量都可以不执行这样的语句，因为局部变量的作用域并不持久

- 在`Java`学习过程中，如果发现某个类定义了`close()`、``release()`或类似名称的方法，无比了解该方法的作用，它很有可能用于释放资源的

  - 例如各种流，都有`close()`方法
  - 定义这样的方法的类，通常都需要连接到内存以外的资源，例如硬盘上的文件、网络上的某个设备等，如果没有调用相关方法，系统可能认为你始终连接着外部资源，会导致这些资源一直被你独占（例如硬盘上的文件无法删除），并且你的对象始终不要会被视为垃圾，长期占用内存

## 3、内存泄漏与内存溢出

- 首先，`JVM`垃圾回收机制是可靠的
- 内存泄漏和内存溢出均是由于不严谨的代码或错误的操作导致的
- 理想的情况下，不再使用的对象应该视为垃圾，将会被回收，如果这样的对象没有被视为垃圾，它将继续在战役内存空间，则视为内存泄漏
- 如果内存泄漏持续发生，导致内存里的对象越来越多（尽量有很多是不再使用的），最终内存中实际存储的数据量会超出可用内存的上线，则是内存溢出
- 其实，少量的内存泄漏并不会导致明显的危害
  - 现代家用计算机的内存空间已经很大，专业的服务器的内存空间更大，绝大部分的对象并不会占用太多内存空间
    - 例如，`5000`长度的``int``数组，每个元素占用`4`字节，则整个数组占用`20`万字节内存空间，约`195KB`，折合约`0.000186GB`
    - 例如，`1000`万字的小说，即为`1000`万长度的`String`，其本质就是`char`数组，每个元素占`2`字节，则该小说占2000万字节内存空间，折合约`0.0186GB`
    - 特别是本机应用，内存泄漏的危害并不明显
    - 如果是网络应用，由于访问量较大，内存泄露的量可能随访问次数不停增加，则有严重危害
  - 即使没有明显危害，也应该注意避免出现内存泄漏
- 为避免出现内存泄漏，应该注意：
  - 当某对象不再需要使用时，即使将其变量重新赋值为null
    - 仅全局变量
    - 需要注意多层引用的数据，例如数组
  - 所有连接外部资源的对象都有释放资源的方法，不再需要使用时即使调用
    - 即使是局部变量
  - 如果你需要使用`try...catch`来捕获某些异常，在`try`代码块中使用到了连接外部资源的对象，请在`finally`代码块中进行释放